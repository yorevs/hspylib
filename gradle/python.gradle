/*
    Gradle Python extension
    Project: HSPyLib
    Created: 1st July, 2020
*/

ext {
  pythonPath = project.hasProperty('pythonPath') ? pythonPath :
    "$sourceRoot:$sourceRoot/main:$sourceRoot/test"
  requirementsFile = project.hasProperty('requirementsFile') ? requirementsFile :
    "$rootProject.projectDir/src/main/requirements.txt"
  failScore = project.hasProperty('failScore') ? failScore : 8.0
}

/* Helper Functions -------------------------------------------------------- */

Collection dirsByPattern(String baseDir, String pattern) {
  def paths = []
  fileTree(baseDir).visit { FileVisitDetails details ->
    if (details.isDirectory() && details.name ==~ pattern) paths << details.file.path
  }
  return paths
}

String dirName(File file) {
  file.getParentFile().getPath()
}

/* Pylint disabled checks ------------------------------------------------- */
project.ext.pylint_disabled_checks =
  project.hasProperty('pylint_disabled_checks')
    ? pylint_disabled_checks
    : [
        'C0103', // invalid-name
        'C0114', // missing-module-docstring
        'C0115', // missing-class-docstring
        'C0116', // missing-function-docstring
        'C0303', // trailing-whitespace
        'C0411', // wrong-import-order
        'E0603', // undefined-all-variable
        'E1101', // no-member
        'R0801', // duplicate-code
        'W0511', // fixme
        'W1113', // keyword-arg-before-vararg
        'C0301', // line-too-long
      ]

/***** Install Group */

/* Used to created the __init__.py files { */
def initTemplate = """# _*_ coding: utf-8 _*_
#
# $app_name v$app_version
#
# Package: %package%
\"\"\"Package initialization.\"\"\"

__all__ = %modules%
%version%
"""
/* } */

/***** Build Group */

/* Cleanup distribution files */
task cleanDist(type: Task) {
  group = 'Build'
  description = "Cleanup distribution files from sourceRoot"
  doLast {
    println "Cleanup distribution files \n\t from $sourceRoot"
    delete dirsByPattern(sourceRoot, /.*dist$/)
    delete dirsByPattern(sourceRoot, /.*build$/)
    delete dirsByPattern(sourceRoot, /.*egg-info$/)
  }
}

/* Clean all compiled (*.py,*.qrc) and cached (__pycache__$) python files from "$sourceRoot" */
task cleanPython(type: Task) {
  group = 'Build'
  description = 'Clean all compiled files and cache directories from sourceRoot'
  doLast {
    println "Cleaning all compiled files and cache directories \n\t from $sourceRoot"
    delete fileTree(sourceRoot).matching {
      include "**/*.pyc"
      include "**/*.qrc"
      include "**/*.log"
      include "**/requirements.txt"
    }
    delete dirsByPattern(sourceRoot, /.*__pycache__$/)
  }
}

/* Compile all python files from sourceRoot */
task compilePython(type: Task) {
  group = 'Build'
  description = 'Compile all python files from sourceRoot'
  doLast {
    println "Compiling Python files from $project.name \n\t $sourceRoot"
    fileTree("$sourceRoot").matching {
      include "**/*.py"
      exclude "**/__init__.py"
    }.each { File file ->
        if (verbose) println "Compiling Python file -> ${file.name}"
        exec {
          commandLine rootProject.python, '-m', 'py_compile', file.path
        }
      }
  }
}

/* Compile all QT resources from sourceRoot */
task compileQrc(type: Task) {
  group = 'Build'
  description = 'Compile all Qt resource files from sourceRoot'
  doLast {
    fileTree("$sourceRoot").matching {
      include "**/*.qrc"
    }.each { File file ->
        if (verbose) println "Compiling Qt Resource -> ${file.name}"
        exec {
          commandLine rootProject.pyrcc, '-m', 'py_compile', file.path
        }
      }
  }
}

/***** Install Group */

/* Find and synchronize all python packages */
task syncPythonPackages(type: Task) {
  group = 'Install'
  description = 'Find and synchronize all python packages'
  doLast {
    project.file("$sourceRoot").traverse(type: groovy.io.FileType.DIRECTORIES) { directory ->
      directory.eachFileMatch(~/^__init__\.py$/) { initFile ->
        def pkg = initFile.getCanonicalPath()
          .replaceAll("$sourceRoot/", "")
          .replaceAll("\\/", "\\.")
          .replaceAll("\\.?__init__\\.py", "")
        def modules = []
        initFile.getParentFile().eachFile() { module ->
          if (!module.name.startsWith("__init__") &&
              !module.name.startsWith("__pycache__") &&
              !module.name.endsWith("setup.py") &&
              ((module.isFile() && module.name.endsWith(".py")) ||
              new File(module.getCanonicalPath() + "/__init__.py").exists())) {
            if (!module.isFile() && verbose) {
              println "Syncing package: ${initFile.getParentFile()}/${module.name}"
            }
            modules << "'${module.name.replaceAll("\\.py", "")}'"
          }
        }
        def ver_file = new File("${initFile.getParentFile()}/.version")
        def version_string = "__version__ = \'$app_version\'"
        initFile.write initTemplate
          .replaceAll("%package%", pkg)
          .replaceAll("%modules%", modules.sort().toString())
          .replaceAll("%version%", version_string)
          .replaceAll("\\[", "\\[\n  ")
          .replaceAll(", ", ", \n  ")
          .replaceAll("\\]", "\n]")
      }
    }
  }
}

/* Install a project in editable mode (i.e. setuptools "develop mode") from a local project path or a VCS url. */
task checkSetupPy(type: Task) {
  group = 'Install'
  description = "Install a project in editable mode (i.e. setuptools develop mode)"
  dependsOn pipRequirements
  finalizedBy cleanDist
  doLast {
    fileTree("$sourceRoot").matching {
      include "**/setup.py"
    }.each { File module ->
        def moduleDir = dirName(module)
        println "Install $project.name in DEVELOPER MODE: $moduleDir -> $module.path"
        exec {
          workingDir "$moduleDir"
          commandLine rootProject.python, '-m', 'pip', 'install', '-e', "$sourceRoot/main"
        }
      }
  }
}

/* Install this application as a python package using module's setup.py */
task installModule(type: Task) {
  group = 'Install'
  description = "Install the module as a python package using module's setup.py"
  dependsOn syncPythonPackages
  dependsOn pipRequirements
  finalizedBy cleanDist
  doLast {
    fileTree("$sourceRoot").matching {
      include "**/setup.py"
    }.each { File module ->
        def moduleDir = dirName(module)
        println "Install $project.name : $moduleDir -> $module.path"
        exec {
          workingDir "$moduleDir"
          commandLine rootProject.python, '-m', 'pip', 'install', '--upgrade', '--user',
            '-r', project.ext.requirementsFile, project.ext.app_name
        }
      }
  }
}

/* Uninstall the module as a python package using module's setup.py */
task uninstallModule(type: Task) {
  group = 'Install'
  description = "Install the module as a python package using module's setup.py"
  doLast {
    fileTree("$sourceRoot/main").matching {
      include "**/setup.py"
    }.each { File module ->
        def moduleDir = "${module.path.replace(module.name, "")}"
        println "Uninstall $project.name : $moduleDir -> $module.path"
        exec {
          workingDir "$moduleDir"
          commandLine rootProject.python, '-m', 'pip', 'uninstall', '-y', project.ext.app_name
        }
      }
  }
}

/***** Verification Group */

/* Run all Qt python tests $sourceRoot */
task check(type: Task) {
  group = 'Verification'
  description = "Run all Qt python tests $sourceRoot/test/**/test_*.py"
  doLast {
    println "Performing unittests from $sourceRoot"
    fileTree("$sourceRoot/test").matching {
      include "**/test_*.py"
    }.each { File file ->
      if (verbose) {
          println ""
          println "  PYTHON_PATHS: "
          println "\t|- ${project.ext.pythonPath.split(':').join('\n\t|- ')}"
          println "Executing unittests from -> $file.name"
          println ""
        }
        exec {
          workingDir = dirName(file)
          environment PYTHONPATH: "$pythonPath"
          commandLine rootProject.python, '-m', 'unittest', '-b', '-f', '-v' ,file.path
        }
      }
  }
}

/* Execute PyLint on sourceRoot */
task pylint(type: Task) {
  group = 'Verification'
  description = "Execute pylint against $sourceRoot"

  doLast {
    assert new File("$project.rootDir" + "/.pylintrc").exists()
    def srcDir = "$sourceRoot/main/$project.name"
    def chk_str = "${pylint_disabled_checks.join(',')}"
    def failScore =
    println "[$project.name] Execute pylint \n\t SRC Root: $srcDir"
    exec {
      workingDir project.rootDir
      commandLine rootProject.python, '-m', 'pylint',
        "--rcfile=$project.rootDir/.pylintrc",
        "--disable=$chk_str", "$srcDir", "--fail-under=$project.ext.failScore"
    }
  }
}

/***** Task Wrappers */

tasks.register('clean', Task) {
  group = 'Build'
  dependsOn cleanPython
  dependsOn cleanDist
}

tasks.register('compile', Task) {
  group = 'Build'
  dependsOn compilePython
  dependsOn compileQrc
}

tasks.register('buildOnly', Task) {
  group = 'Build'
  dependsOn clean
  mustRunAfter clean
  dependsOn compile
  mustRunAfter compile
}

tasks.register('build', Task) {
  group = 'Build'
  dependsOn clean
  mustRunAfter clean
  dependsOn installDependencies
  mustRunAfter installDependencies
  dependsOn compile
  mustRunAfter compile
  dependsOn check
}

tasks.register('install', Task) {
  group = 'Install'
  dependsOn build
  mustRunAfter build
  dependsOn installModule
}
