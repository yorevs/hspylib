/*
    Gradle Python extension
    Project: HSPyLib
    Created: 1st July, 2020
*/

ext {
  pythonPath = "${sourceRoot}:${sourceRoot}/main:${sourceRoot}/test:${sourceRoot}/app:${sourceRoot}/demo"
  requirementsFile = "${rootProject.projectDir}/src/main/requirements.txt"
}

/* Helper Functions -------------------------------------------------------- */

Collection dirsByPattern(String baseDir, String pattern) {
  def paths = []
  fileTree(baseDir).visit { FileVisitDetails details ->
    if (details.isDirectory() && details.name ==~ pattern) paths << details.file.path
  }
  return paths
}

String dirName(File file) {
  file.getParentFile().getPath()
}

/* Pylint disabled checks ------------------------------------------------- */
project.ext.pylint_disabled_checks =
  project.hasProperty('pylint_disabled_checks')
    ? pylint_disabled_checks
    : [
        'C0103', // invalid-name
        'C0114', // missing-module-docstring
        'C0115', // missing-class-docstring
        'C0116', // missing-function-docstring
        'C0303', // trailing-whitespace
        'C0411', // wrong-import-order
        'E0603', // undefined-all-variable
        'E1101', // no-member
        'R0801', // duplicate-code
        'W0511', // fixme
      ]

/***** Install Group */

/* Used to created the __init__.py files { */
def initTemplate = """# _*_ coding: utf-8 _*_
#
# ${project.ext.app_name} v${projectVersion}
#
# Package: %package%
\"\"\"Package initialization.\"\"\"

__all__ = %modules%
%version%"""
/* } */

/***** Build Group */

/* Cleanup distribution files */
task cleanDist(type: Delete) {
  group = 'Build'
  description = "Cleanup distribution files from rootProject.projectDir"
  def projectRoot = "${rootProject.projectDir}"
  println "Cleanup distribution files from ${projectRoot}"
  delete dirsByPattern(projectRoot, /.*dist$/)
  delete dirsByPattern(projectRoot, /.*build$/)
  delete dirsByPattern(projectRoot, /.*egg-info$/)
}

/* Clean all compiled (*.py,*.qrc) and cached (__pycache__$) python files from "${sourceRoot}" */
task cleanPython(type: Delete) {
  group = 'Build'
  description = 'Clean all compiled (*.py,*.qrc) files and cached (__pycache__/) directories from sourceRoot'
  println "Cleaning all compiled (*.py,*.qrc) files and cached (__pycache__/) directories  from ${sourceRoot}..."
  delete fileTree(sourceRoot).matching {
    include "**/*.pyc"
    include "**/*.qrc"
  }
  delete dirsByPattern(sourceRoot, /.*__pycache__$/)
}

/* Compile all python files from sourceRoot */
task compilePython(type: Task) {
  group = 'Build'
  description = 'Compile all python files from sourceRoot'
  doLast {
    fileTree("${sourceRoot}").matching {
      include "**/*.py"
      exclude "**/__init__.py"
    }.each { File file ->
        println "Compiling Python file -> ${file.name}"
        exec {
          commandLine rootProject.python, '-m', 'py_compile', file.path
        }
      }
  }
}

/* Compile all QT resources from sourceRoot */
task compileQrc(type: Task) {
  group = 'Build'
  description = 'Compile all Qt resource files from sourceRoot'
  doLast {
    fileTree("${sourceRoot}").matching {
      include "**/*.qrc"
    }.each { File file ->
        println "Compiling Qt Resource -> ${file.name}"
        exec {
          commandLine rootProject.pyrcc, '-m', 'py_compile', file.path
        }
      }
  }
}

/***** Install Group */

/* Find and synchronize all python packages */
task syncPythonPackages(type: Task) {
  group = 'Install'
  description = 'Find and synchronize all python packages'
  doLast {
    project.file("${sourceRoot}").traverse(type: groovy.io.FileType.DIRECTORIES) { directory ->
      directory.eachFileMatch(~/^__init__\.py$/) { initFile ->
        def pkg = initFile.getCanonicalPath()
          .replaceAll("${sourceRoot}/", "")
          .replaceAll("\\/", "\\.")
          .replaceAll("\\.?__init__\\.py", "")
        def modules = []
        initFile.getParentFile().eachFile() { module ->
          if (!module.name.startsWith("__init__") &&
              !module.name.startsWith("__pycache__") &&
              !module.name.endsWith("setup.py") &&
              ((module.isFile() && module.name.endsWith(".py")) ||
              new File(module.getCanonicalPath() + "/__init__.py").exists())) {
            if (!module.isFile()) {
              println "Syncing package: ${initFile.getParentFile()}/${module.name}"
            }
            modules << "'${module.name.replaceAll("\\.py", "")}'"
          }
        }
        def ver_file = new File("${initFile.getParentFile()}/.version")
        def version_string = ver_file.exists() ? "__version__ = \"${ver_file.text.trim()}\"\n" : ''
        initFile.write initTemplate
          .replaceAll("%package%", pkg)
          .replaceAll("%modules%", modules.sort().toString())
          .replaceAll("%version%", version_string)
          .replaceAll("\\[", "\\[\n  ")
          .replaceAll(", ", ", \n  ")
          .replaceAll("\\]", "\n]")
      }
    }
  }
}

/* Install all required python packages */
task installDependencies(type: Task) {
  group = 'Install'
  description = 'Install all required python packages'
  doLast {
    println "Upgrading pip module to the latest "
    exec {
      commandLine rootProject.python, '-m', 'pip', 'install', '--user', '--upgrade', 'pip'
    }
    println "Installing dependencies using pip "
    deps.each { dep ->
      exec {
        commandLine rootProject.python, '-m', 'pip', 'install', '--user', dep
      }
    }
  }
}

/* Install this application as a python package using module's setup.py */
task installModule(type: Task) {
  group = 'Install'
  description = "Install the module as a python package using module's setup.py"
  dependsOn syncPythonPackages
  doLast {
    def depsFile = project.file("${project.ext.requirementsFile}")
    depsFile.write ''
    project.ext.deps.each { dep ->
      depsFile.append dep + '\n'
    }
    copy {
        from("${rootProject.projectDir}") {
          include 'README.md'
        }
        into "${sourceRoot}/main"
    }
    fileTree("${sourceRoot}").matching {
      include "**/setup.py"
    }.each { File module ->
        def moduleDir = dirName(module)
        println "Installing ${rootProject.name} from ${moduleDir} -> ${module.path}"
        exec {
          workingDir "${moduleDir}"
          commandLine rootProject.python, '-m', 'pip', 'install', '--use-feature=in-tree-build', '--user', '.'
        }
      }
  }
}

/* Uninstall the module as a python package using module's setup.py */
task uninstallModule(type: Task) {
  group = 'Install'
  description = "Uninstall the module as a python package using module's setup.py"
  doLast {
    fileTree("${sourceRoot}/main").matching {
      include "**/setup.py"
    }.each { File file ->
        def moduleDir = "${file.path.replace(file.name, "")}"
        println "Removing python modules from: ${file.path}"
        exec {
          workingDir "${moduleDir}"
          commandLine rootProject.python, '-m', 'pip', 'uninstall', '-y', "${rootProject.name}"
        }
      }
  }
}

/***** Verification Group */

task check(type: Task) {
  group = 'Verification'
  description = 'Run all Qt python tests "${sourceRoot}/test/**/test_*.py"'
  dependsOn compilePython
  doLast {
    fileTree("${sourceRoot}/test").matching {
      include "**/test_*.py"
    }.each { File file ->
        println ""
        println "Running unittests -> ${file.name}"
        println "  |- PYTHON_PATH: ${rootProject.ext.pythonPath}"
        println ""
        exec {
          workingDir = dirName(file)
          environment PYTHONPATH: "${rootProject.ext.pythonPath}"
          commandLine rootProject.python, '-m', 'unittest', '-b', '-f', '-v', file.path
        }
      }
  }
}

/* Execute PyLint on sourceRoot */
task pylint(type: Task) {
  group = 'Verification'
  description = 'Run pylint on "${sourceRoot}"'
  doLast {
    def chk_str = "${pylint_disabled_checks.join(',')}"
    exec {
      workingDir "${rootDir}"
      commandLine rootProject.python, '-m', 'pylint', '--rcfile=.pylintrc', "--disable=${chk_str}", sourceRoot
    }
  }
}

/***** Task Wrappers */

task clean(type: Task) {
  group = 'Build'
  dependsOn cleanPython
}

task compile(type: Task) {
  group = 'Build'
  dependsOn compilePython
  dependsOn compileQrc
}

task test(type: Task) {
  group = 'Verification'
  dependsOn compile
  mustRunAfter compile
  dependsOn check
}

task build(type: Task) {
  group = 'Build'
  dependsOn clean
  mustRunAfter clean
  dependsOn installDependencies
  mustRunAfter installDependencies
  dependsOn test
}

task buildOnly(type: Task) {
  group = 'Build'
  dependsOn clean
  mustRunAfter clean
  dependsOn installDependencies
  mustRunAfter installDependencies
  dependsOn compile
  mustRunAfter compile
}

task install(type: Task) {
  group = 'Install'
  dependsOn installDependencies
  mustRunAfter installDependencies
  dependsOn buildOnly
  mustRunAfter buildOnly
  dependsOn uninstallModule
  mustRunAfter uninstallModule
  dependsOn installModule
}
