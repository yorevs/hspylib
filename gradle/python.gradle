def initTemplate = """# _*_ coding: utf-8 _*_
#
# Package: %package%

__all__ = %modules%
"""

ext {
  pythonPath = "${sourceRoot}:${sourceRoot}/main:${sourceRoot}/test"
}

/* Helper Functions -------------------------------------------------------- */

Collection dirsByPattern(String baseDir, String pattern) {
  def paths = []
  fileTree(baseDir).visit { FileVisitDetails details ->
      if (details.isDirectory() && details.name ==~ pattern) paths << details.file.path
  }
  return paths
}

String dirName(File file) {
  file.getParentFile().getPath()
}

/* Python Tasks ------------------------------------------------------------- */

/***** Other Group */

task syncPackages(type: Task) {
  group = 'Other'
  description = 'Find and synchronize all python packages'
  doLast {
    project.file("${sourceRoot}").traverse(type: groovy.io.FileType.DIRECTORIES) { directory ->
      directory.eachFileMatch(~/^__init__\.py$/) { initFile ->
        def pkg = initFile.getCanonicalPath()
          .replaceAll("${sourceRoot}/(main|test|demo)/", "")
          .replaceAll("\\/", "\\.")
          .replaceAll("\\.__init__\\.py", "")
        def modules = []
        initFile.getParentFile().eachFile() { module ->
          if (!module.name.startsWith("__init__") &&
              !module.name.startsWith("__pycache__")) {
            modules << "'${module.name.replaceAll("\\.py", "")}'"
          }
        }
        initFile.write initTemplate
          .replaceAll("%package%", pkg)
          .replaceAll("%modules%", modules.sort().toString())
          .replaceAll("\\[", "\\[\n  ")
          .replaceAll(", ", ", \n  ")
          .replaceAll("\\]", "\n]")
      }
    }
  }
}

/***** Install Group */

task installDependencies(type: Task) {
  group = 'Install'
  description = 'Install all required python packages'
  doLast {
    deps.each { String dep ->
      println "Upgrading pip module to the latest "
      exec {
        commandLine rootProject.python, '-m', 'pip', 'install', '--user', '--upgrade', 'pip'
      }
      exec {
        commandLine rootProject.python, '-m', 'pip', 'install', '--user', dep
      }
    }
  }
}

task installModule(type: Task) {
  group = 'Install'
  description = 'Install this application as a python package from "**/setup.py"'
  doLast {
    def depsFile = new File("DEPS.txt")
    depsFile.write ''
    project.ext.deps.each { dep ->
      depsFile.append dep + '\n'
    }
    copy {
        from("$rootProject.projectDir") {
          include 'README.md'
          include 'VERSION'
          include 'DEPS.txt'
        }
        into "${sourceRoot}/main"
    }
    fileTree("${sourceRoot}").matching {
      include "**/setup.py"
    }.each { File module ->
        def moduleDir = dirName(module)
        println "Installing ${rootProject.name} from ${moduleDir} -> ${module.path}"
        exec {
          workingDir "${moduleDir}"
          commandLine rootProject.python, '-m', 'pip', 'install', '--user', '.'
        }
      }
  }
}

task uninstallModule(type: Task) {
  group = 'Install'
  description = 'Uninstall all python modules from "**/setup.py"'
  doLast {
    fileTree("${sourceRoot}/main").matching {
      include "**/setup.py"
    }.each { File file ->
        def moduleDir = "${file.path.replace(file.name, "")}"
        println "Removing python modules from: ${file.path}"
        exec {
          workingDir "${moduleDir}"
          commandLine rootProject.python, '-m', 'pip', 'uninstall', '-y', "${rootProject.name}"
        }
      }
  }
}

/***** Build Group */

task cleanPython(type: Delete) {
  group = 'Build'
  description = 'Clean all compiled and cached python files from "${sourceRoot}"'
  doLast {
    println "Cleaning up compiled and cached files ..."
    delete fileTree(sourceRoot).matching {
      include "**/*.pyc"
    }
    delete dirsByPattern(sourceRoot, /.*__pycache__$/)
  }
}

task compilePython(type: Task) {
  group = 'Build'
  description = 'Compile all python files from "${sourceRoot}/main"'
  doLast {
    fileTree("${sourceRoot}/main").matching {
      include "**/*.py"
      exclude "**/__init__.py"
    }.each { File file ->
        println "Compiling Python file -> ${file.name}"
        exec {
          commandLine rootProject.python, '-m', 'py_compile', file.path
        }
      }
  }
}

task compilePythonTest(type: Task) {
  group = 'Build'
  description = 'Compile all python test files from "${sourceRoot}/test"'
  doLast {
    fileTree("${sourceRoot}/test").matching {
      include "**/test_*.py"
      exclude "**/__init__.py"
    }.each { File file ->
        println "Compiling Python Test file -> ${file.name}"
        exec {
          commandLine rootProject.python, '-m', 'py_compile', file.path
        }
      }
  }
}

task compileQrc(type: Task) {
  group = 'Build'
  description = 'Compile all Qt resource files from "${sourceRoot}/main"'
  doLast {
    fileTree("${sourceRoot}/main").matching {
      include "**/*.qrc"
    }.each { File file ->
        println "Compiling Qt Resource -> ${file.name}"
        exec {
          commandLine rootProject.pyrcc, '-m', 'py_compile', file.path
        }
      }
  }
}

task updateVersion {
  group = 'Build'
  description = 'Update the VERSION file to match the build.gradle version'
  doLast {
    def ver = project.ext.version
    def v_file = versionFile
    println "Updating version to: ${ver}"
    assert file("${v_file}").exists()
    new File("${v_file}").text = "${ver}"
    ant.replaceregexp(file: "${v_file}", match:'^([0-9]{1,2}\\.)[0-9]{1,3}$', replace:"${ver}", flags:'g', byline:true)
    println "Project: [${rootProject.name}] Version: " + file("${v_file}").text
  }
}

/***** Run Group */

task runTest(type: Task) {
  group = 'Run'
  description = 'Run all Qt python tests "${sourceRoot}/test/**/test_*.py"'
  dependsOn compilePython
  dependsOn compilePythonTest
  doLast {
    fileTree("${sourceRoot}/test").matching {
      include "**/test_*.py"
    }.each { File file ->
        println "Running unittests -> ${file.name}"
        println "  |- PYTHON_PATH: ${rootProject.ext.pythonPath}"
        exec {
          workingDir = dirName(file)
          environment PYTHONPATH: "${rootProject.ext.pythonPath}"
          commandLine rootProject.python, '-m', 'unittest', '-f', file.path
        }
      }
  }
}

task run(type: Task) {
  group = 'Run'
  description = 'Run main application'
  dependsOn compilePython
  doLast {
    fileTree("${sourceRoot}").matching {
      include "**/${application}"
    }.each { File app ->
        def appDir = dirName(app)
        def runEnv = findProperty('env') ?: "vdev"
        def dryRun = findProperty('dry') ?: "true"
        def multiThread = findProperty('multi') ?: "true"
        def orderNum = findProperty('order') ?: "12345"
        println "Running ${app} [${appDir}]"
        println "  |- PYTHON_PATH: ${rootProject.ext.pythonPath}"
        println "  |- APP: ${app.path}"
        new ByteArrayOutputStream().withStream { os ->
          def result = exec {
            workingDir "${appDir}"
            errorOutput = os
            standardOutput = os
            environment PYTHONPATH: "${rootProject.ext.pythonPath}", SOURCE_ROOT: "${sourceRoot}"
            commandLine rootProject.python, "${application}", "-f", "${app}", "-e", "${runEnv}", "-o", "${orderNum}", "-r", "${dryRun}", "-t", "${multiThread}"
          }
          print(os.toString())
        }
      }
  }
}

/***** Task Wrappers */

task compile(type: Task) {
  group = 'Build'
  dependsOn compilePython
  dependsOn compileQrc
  dependsOn compilePythonTest
}

task clean(type: Task) {
  group = 'Build'
  dependsOn cleanPython
}

task test(type: Task) {
  group = 'Test'
  dependsOn compile
  mustRunAfter compile
  dependsOn runTest
}

task build(type: Task) {
  group = 'Build'
  dependsOn clean
  mustRunAfter clean
  dependsOn installDependencies
  mustRunAfter installDependencies
  dependsOn updateVersion
  dependsOn test
}

task install(type: Task) {
  group = 'Install'
  dependsOn installDependencies
  mustRunAfter installDependencies
  dependsOn build
  mustRunAfter build
  dependsOn uninstallModule
  mustRunAfter uninstallModule
  dependsOn installModule
}
