/*
    Gradle dependencies extension

    Created: 4th March, 2021
    License: MIT - Please refer to <https://opensource.org/licenses/MIT>
    Copyright 2022, HSPyLib team
*/

/* Project file definitions */
project.ext.depsFile = "$project.projectDir/dependencies.hspd"
project.ext.reqsFile = "$project.projectDir/src/main/requirements.txt"

/* Mode Map*/
def modesMap = [lt: '<', le: '<=', eq: '==', ne: '!=', compat: '~=', gt: '>', ge: '>=', none: null]

/* List of project dependencies*/
project.ext.deps = []

/* Helper Functions -------------------------------------------------------- */

void readDependencies() {
  def depsFile = new File(depsFile)
  depsFile.eachLine { line ->
    def dep = null
    if (dep = line =~ /package: ([a-zA-Z0-9-_.]+), version: (latest|[0-9]+(\.[0-9]+){0,4}), space: (user|global), mode: (lt|le|eq|compat|ne|gt|ge|none)/) {
      dep.each {
        deps << [package: "${it[1]}", version: "${it[2]}", space: "${it[4]}", mode: "${it[5]}"]
      }
    }
    else if (dep = line =~ /package: ([a-zA-Z0-9-_.]+), version: (latest|[0-9]+(\.[0-9]+){0,4}), space: (user|global)/) {
      dep.each {
        deps << [package: "${it[1]}", version: "${it[2]}", space: "${it[4]}", mode: "compat"]
      }
    }
    else {
      if ( line.startsWith('package: ') ) {
        throw new GradleException("Invalid hspd syntax $line. Usage: "
          + "package: <pkg_name>, version: <latest|versionNum>, "
          + "space: <user|global>, [mode: <lt|le|eq|compat|ne|gt|ge|none>]")
      }
    }
  }
}

/* Tasks ------------------------------------------------------------------- */

/* Gather all project requirements and generate a requirements file */
task requirements(type: Task) {
  group = 'Dependencies'
  description = 'Gather all project requirements and generate a requirements file'
  doLast {
    readDependencies()
    def requirements = new File(reqsFile)
    requirements.setText("###### Requirements file for $project.name ######\n\n")
    deps.each { dep ->
      def mode = modesMap[dep.mode]
      if ('latest' == dep.version) requirements.append("$dep.package>=$dep.version\n")
      else {
        if (mode != null) requirements.append("$dep.package$mode$dep.version\n")
        else requirements.append("$dep.package\n")
      }
    }
  }
}

/* List project dependencies */
task listDependencies(type: Task) {
  group = 'Dependencies'
  description = 'List project dependencies'
  doLast {
    println "\nListing dependencies from:\n\t${depsFile}\n"
    readDependencies()
    deps.each { dep ->
      println("Package: ${dep.package}, Version: ${dep.version}, Space: ${dep.space}, Mode: ${dep.mode}")
    }
  }
}

/* Install all required python packages */
task installDependencies(type: Task) {
  group = 'Dependencies'
  description = 'Install all required python packages'
  doLast {
    readDependencies()
    deps.each { dep ->
      println "\nInstalling Package: $dep.package  Version: $dep.version  Space: $dep.space"
      def args = [rootProject.python, '-m', 'pip', 'install']
      if (! verbose) args << '-q'
      if ('user' == dep.space) args << '--user'
      if ('latest' == dep.version) args << ['--upgrade', dep.package]
      else args << ['-Iv', "${dep.package}~=${dep.version}"]
      exec {
        commandLine args.flatten()
      }
    }
  }
}
