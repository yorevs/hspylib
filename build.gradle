
buildscript {
  project.ext.gradleProperties = "$rootProject.projectDir/properties.gradle"
  apply from: gradleProperties
}

apply from: "properties.gradle"

ext {
  startTime = System.currentTimeMillis()
  python = "python${pythonVersion}"
  pyrcc = "pyrcc3${pyrccVersion}"
}

task props {
  doLast {
    File propsFile = new File(gradleProperties)
    if (propsFile.exists()) {
      propsFile.eachLine { line ->
        def strLine = "${line.substring(16, line.length() - 1)}"
        def (name, value) = strLine.tokenize( ',' )
        println "${name.padRight(25, '.')} => ${value.trim()}"
      }
    }
  }
}

task cleanPython(type: Delete) {
  description = 'Clean all compiled and cached python files from "src"'
  doLast {
    delete fileTree("src").matching {
      include "**/*.pyc"
      include "**/__pycache__/"
    }
  }
}

task compilePython(type: Task) {
  description = 'Compile all python files from "src/main"'
  doLast {
    fileTree("src/main").matching {
      include "**/*.py"
      exclude "**/__init__.py"
      exclude "**/test_*.py"
    }.each { File file ->
        println "Compiling Python file -> ${file.name}"
        exec {
          commandLine rootProject.python, '-m', 'py_compile', file.path
        }
      }
  }
}

task compilePythonTest(type: Task) {
  description = 'Compile all python test files from "src/test"'
  doLast {
    fileTree("src/test").matching {
      include "**/test_*.py"
      exclude "**/__init__.py"
    }.each { File file ->
        println "Compiling Python Test file -> ${file.name}"
        exec {
          commandLine rootProject.python, '-m', 'py_compile', file.path
        }
      }
  }
}

task compileQrc(type: Task) {
  description = 'Compile all Qt resource files from "src/main"'
  doLast {
    fileTree("src/main").matching {
      include "**/*.qrc"
    }.each { File file ->
        println "Compiling Qt Resource -> ${file.name}"
        exec {
          commandLine rootProject.pyrcc, '-m', 'py_compile', file.path
        }
      }
  }
}

task runTest(type: Task) {
  description = 'Run all Qt python tests "src/test/**/test_*.py"'
  doLast {
    fileTree("src/test").matching {
      include "**/test_*.py"
    }.each { File file ->
        println "Running test -> ${file.name}"
        exec {
          commandLine rootProject.python, file.path
        }
      }
  }
}

task installModule(type: Task) {
  description = 'Install all python modules from "**/setup.py"'
  doLast {
    fileTree("src/main").matching {
      include "**/setup.py"
    }.each { File file ->
        def moduleDir = "${file.path.replace(file.name, "")}"
        println "Installing python modules from: ${file.path}"
        new File("${moduleDir}").listFiles().each {
          if (it.directory && it.name != '__pycache__') {
            def moduleName = it.name
            exec {
              workingDir "${moduleDir}"
              commandLine rootProject.python, '-m', 'pip', 'install', '.'
            }
          }
        }
      }
  }
}

task uninstallModule(type: Task) {
  description = 'Uninstall all python modules from "**/setup.py"'
  doLast {
    fileTree("src/main").matching {
      include "**/setup.py"
    }.each { File file ->
        def moduleDir = "${file.path.replace(file.name, "")}"
        println "Removing python modules from: ${file.path}"
        new File("${moduleDir}").listFiles().each {
          if (it.directory && it.name != '__pycache__') {
            def moduleName = it.name
            exec {
              workingDir "${moduleDir}"
              commandLine rootProject.python, '-m', 'pip', 'uninstall', '-y', moduleName
            }
          }
        }
      }
  }
}

task clean(type: Task) {
  dependsOn cleanPython
}

task test(type: Task) {
  dependsOn compilePythonTest
  mustRunAfter compilePythonTest
  dependsOn runTest
}

task build(type: Task) {
  dependsOn compileQrc
  dependsOn compilePython
  mustRunAfter compileQrc
  mustRunAfter compilePython
  dependsOn test
}

task install(type: Task) {
  dependsOn build
  mustRunAfter build
  dependsOn uninstallModule
  mustRunAfter uninstallModule
  dependsOn installModule
}
